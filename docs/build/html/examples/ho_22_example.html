<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Tutorial: Ho, M. et al. (2022) &mdash; Psychex 0.1 documentation</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../_static/css/theme.css?v=19f00094" />

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../_static/jquery.js?v=5d32c60e"></script>
        <script src="../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="../_static/documentation_options.js?v=2709fde1"></script>
        <script src="../_static/doctools.js?v=9a2dae69"></script>
        <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="FAQ" href="faq.html" />
    <link rel="prev" title="Tutorial: N-Arm Bandit Task" href="../tutorial/n_arm_bandit.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            Psychex
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../tutorial/getting_started.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tutorial/main_ideas.html">Key Concepts in Psychex</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tutorial/loading_static_content.html">Handling Static Content</a></li>
<li class="toctree-l1"><a class="reference internal" href="../code_docs/primitives.html">Primitives</a></li>
<li class="toctree-l1"><a class="reference internal" href="../code_docs/paradigms.html">Paradigm-Based Composite Classes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../code_docs/Utilities.html">Meta-Classes, Utilities, and Support Classes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tutorial/aesthetics.html">Styles and Aesthetics</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tutorial/interactions.html">Handling User Interactions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tutorial/n_arm_bandit.html">Tutorial: N-Arm Bandit Task</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Tutorial: Ho, M. <em>et al.</em> (2022)</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#setting-up">Setting Up</a></li>
<li class="toctree-l2"><a class="reference internal" href="#building-a-gridworld">Building a Gridworld</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#gridworld-background">Gridworld Background</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#extending-the-gridworld-class">Extending the Gridworld Class</a></li>
<li class="toctree-l2"><a class="reference internal" href="#movement-control-and-key-press-events">Movement Control and Key-Press Events</a></li>
<li class="toctree-l2"><a class="reference internal" href="#adding-more-complex-overlays">Adding More Complex Overlays</a></li>
<li class="toctree-l2"><a class="reference internal" href="#overriding-the-parent-draw-method">Overriding the Parent Draw Method</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="faq.html">FAQ</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tutorial/js_background_knowledge.html">JavaScript - Important Concepts</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Psychex</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Tutorial: Ho, M. <em>et al.</em> (2022)</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/examples/ho_22_example.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="tutorial-ho-m-et-al-2022">
<h1>Tutorial: Ho, M. <em>et al.</em> (2022)<a class="headerlink" href="#tutorial-ho-m-et-al-2022" title="Link to this heading"></a></h1>
<p>This example recreates Ho &amp; colleagues’ experiment from their 2022 Nature paper titled <em>People construct simplified mental representations to plan</em>.</p>
<p>In this work, they use an experimental paradigm where participants see a gridworld populated by obstacles,
a start point, and an end point. The participant is tasked with navigating to the end point while avoiding the obstacles.
Initially, all obstacles are visible during navigation (this is changed in later experiments).
Finally, they are queried about their awareness of a particular obstacle during the trial.</p>
<section id="setting-up">
<h2>Setting Up<a class="headerlink" href="#setting-up" title="Link to this heading"></a></h2>
<p>We’ll start by copying the skeleton folder from <em>examples</em>. This contains all the dependencies and boilerplate code we need to get started.
Next, we can open a terminal, navigate to the root directory, and deploy a server to serve static files. For example, using Python:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">python</span> <span class="o">-</span><span class="n">m</span> <span class="n">http</span><span class="o">.</span><span class="n">server</span>
</pre></div>
</div>
<p>If we open a browser at <code class="docutils literal notranslate"><span class="pre">127.0.0.1:8000</span></code>, we’ll see the Psychex welcome text.</p>
</section>
<section id="building-a-gridworld">
<h2>Building a Gridworld<a class="headerlink" href="#building-a-gridworld" title="Link to this heading"></a></h2>
<p>From the skeleton, we’ve already got out preload, setup, and draw functions. Let’s delete the Psychex welcome text, so <em>setup</em> looks like this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">function</span> <span class="n">setup</span><span class="p">(){</span>
    <span class="n">var</span> <span class="n">canvas</span> <span class="o">=</span> <span class="n">createCanvas</span><span class="p">(</span><span class="n">windowWidth</span><span class="p">,</span> <span class="n">windowHeight</span><span class="p">);</span>
    <span class="n">pixelDensity</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="n">frameRate</span><span class="p">(</span><span class="mi">60</span><span class="p">)</span>
    <span class="n">canvas</span><span class="o">.</span><span class="n">parent</span><span class="p">(</span><span class="s2">&quot;gameCanvas&quot;</span><span class="p">)</span>
    <span class="n">myGame</span> <span class="o">=</span> <span class="n">new</span> <span class="n">Game</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Psychex has a gridworld class that provides helpful functionality and will handle a chunk of the heavy lifting.
You can look behind the scenes in more detail from the docs (TODO ref docs).</p>
<section id="gridworld-background">
<h3>Gridworld Background<a class="headerlink" href="#gridworld-background" title="Link to this heading"></a></h3>
<p>Before we fully dive into the tutorial, let’s explore a couple of the features of the gridworld class. If you’re already familiar with it, you may
wish to skip this part. We can instantiate a gridworld in the following way:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">var</span> <span class="n">myGrid</span> <span class="o">=</span> <span class="n">new</span> <span class="n">GridWorld</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">nRows</span><span class="p">,</span> <span class="n">nCols</span><span class="p">,</span> <span class="n">align</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">);</span>
</pre></div>
</div>
<p>where <em>x, y</em> are the coordinates on the screen, <em>w, h</em> are the width and height of the gridworld respectively, <em>nRows, nCols</em> are the number of rows
and number of columns respectively, <em>align</em> indicates whether the anchor point (i.e. where <em>x, y</em> is placed) is at the centre or top-LHS corner of the grid,
and kwargs is optional and allows for keyword-arguments to be passed in. For instance, we might initialise the grid with</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">content</span><span class="o">.</span><span class="n">myGrid</span> <span class="o">=</span> <span class="n">new</span> <span class="n">GridWorld</span><span class="p">(</span><span class="mi">50</span><span class="p">,</span> <span class="mi">40</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">70</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="s2">&quot;CENTER&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>if we want a 4x4 grid positioned around a central anchor point at <em>50, 40</em>.</p>
<p>Each cell in a grid holds a <em>pRectangle</em> object, which means that anything you could do to a <em>pRectangle</em>, you can do to individual grid cells.
For instance, if we want to make a single cell clickable and have its colour change on click, we can use the <cite>onCellClick</cite> method.
This makes a single cell clickable, and accepts a callback to run <cite>onClick</cite>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">Make</span> <span class="n">the</span> <span class="n">first</span> <span class="n">cell</span> <span class="ow">in</span> <span class="n">the</span> <span class="n">grid</span> <span class="p">(</span><span class="n">index</span> <span class="mi">0</span><span class="p">)</span> <span class="n">turn</span> <span class="n">red</span> <span class="n">onClick</span>
<span class="n">content</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">onCellClick</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="o">//</span> <span class="n">e</span> <span class="n">contains</span> <span class="n">a</span> <span class="n">reference</span> <span class="n">to</span> <span class="n">the</span> <span class="n">cell</span> <span class="n">rectangle</span><span class="p">,</span> <span class="ow">and</span> <span class="ow">is</span> <span class="n">a</span> <span class="n">handy</span> <span class="n">shortcut</span>
    <span class="n">e</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">backgroundColor</span><span class="p">:</span> <span class="s2">&quot;red&quot;</span><span class="p">});</span>
<span class="p">})</span>

<span class="o">//</span> <span class="n">We</span> <span class="n">can</span> <span class="n">also</span> <span class="n">access</span> <span class="n">a</span> <span class="n">cell</span> <span class="n">by</span> <span class="n">it</span><span class="s1">&#39;s [row, col] coordinates, without changing the method</span>
<span class="n">content</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">onCellClick</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="o">//</span> <span class="n">randomly</span> <span class="n">change</span> <span class="n">to</span> <span class="n">a</span> <span class="n">new</span> <span class="n">colour</span> <span class="kn">from</span> <span class="nn">the</span> <span class="nb">list</span>
    <span class="n">e</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">backgroundColor</span><span class="p">:</span> <span class="n">_</span><span class="o">.</span><span class="n">sample</span><span class="p">([</span><span class="s2">&quot;red&quot;</span><span class="p">,</span> <span class="s2">&quot;green&quot;</span><span class="p">,</span> <span class="s2">&quot;yellow&quot;</span><span class="p">,</span> <span class="s2">&quot;blue&quot;</span><span class="p">])});</span>
<span class="p">})</span>
</pre></div>
</div>
<p>And to set the aesthetics of a single cell in advance, we can use the wrapper method <cite>setCellProps</cite>, in a similar way:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">content</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">setCellProps</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">{</span><span class="n">backgroundColor</span><span class="p">:</span> <span class="s2">&quot;red&quot;</span><span class="p">});</span>
</pre></div>
</div>
<p>which makes setting properties a little simpler.</p>
<p>We’ll see more details of the Gridworld class as we proceed with the tutorial.</p>
</section>
</section>
<section id="extending-the-gridworld-class">
<h2>Extending the Gridworld Class<a class="headerlink" href="#extending-the-gridworld-class" title="Link to this heading"></a></h2>
<p>We’ll begin by creating a new class that extends the Psychex Gridworld class. In this experiment, we want a few components of the grid to
remain the same between trials, and others to vary, so by having a custom wrapper this will be much easier.</p>
<p>Start by defining the class. You can either do this inside <cite>main.js</cite>, or in a new file. If you do it in a new file, don’t forget to import it
inside <cite>main.html</cite>. We can extend the class and pass parameters into the <code class="docutils literal notranslate"><span class="pre">super</span></code> method:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">CustomGrid</span> <span class="n">extends</span> <span class="n">GridWorld</span><span class="p">{</span>
    <span class="n">constructor</span><span class="p">(){</span>
        <span class="nb">super</span><span class="p">(</span><span class="mi">50</span><span class="p">,</span> <span class="mi">40</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">70</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="s2">&quot;CENTER&quot;</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This grid has 11 rows and 11 columns, following the grid used by the original authors. Since we’re extending from the Gridworld class, we still have
access to the parent <em>draw</em> method, and can render define and render it as normal:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">function</span> <span class="n">setup</span><span class="p">(){</span>
    <span class="o">//</span> <span class="o">...</span> <span class="n">preamble</span> <span class="o">...</span> <span class="o">//</span>

    <span class="n">content</span><span class="o">.</span><span class="n">grid</span> <span class="o">=</span> <span class="n">new</span> <span class="n">CustomGrid</span><span class="p">();</span>
<span class="p">}</span>

<span class="n">function</span> <span class="n">draw</span><span class="p">(){</span>
    <span class="n">clear</span><span class="p">();</span>

    <span class="n">content</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">draw</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Each grid in a trial contains a black cross that is impassible by the player. Let’s draw the cross. Don’t worry about player movement and setting things
as obstacles etc. for now, we’ll get to that. The cross is defined on row 5, cols 3 -&gt; 7 inclusive, and column 5, rows 3-&gt; 7 inclusive.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Remember, indexing always starts from 0!</p>
</div>
<p>We’ll define this within the constructor:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">CustomGrid</span> <span class="n">extends</span> <span class="n">GridWorld</span><span class="p">{</span>
    <span class="n">constructor</span><span class="p">(){</span>
        <span class="nb">super</span><span class="p">(</span><span class="mi">50</span><span class="p">,</span> <span class="mi">40</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">70</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="s2">&quot;CENTER&quot;</span><span class="p">);</span>

        <span class="o">//</span> <span class="o">...</span> <span class="n">New</span> <span class="n">code</span> <span class="o">...</span> <span class="o">//</span>
        <span class="n">_</span><span class="o">.</span><span class="n">range</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span><span class="o">.</span><span class="n">forEach</span><span class="p">(</span><span class="n">i</span> <span class="o">=&gt;</span> <span class="p">{</span>
            <span class="n">this</span><span class="o">.</span><span class="n">setCellProps</span><span class="p">([</span><span class="mi">5</span><span class="p">,</span> <span class="n">i</span><span class="p">],</span> <span class="p">{</span><span class="n">backgroundColor</span><span class="p">:</span> <span class="s2">&quot;black&quot;</span><span class="p">});</span>
            <span class="n">this</span><span class="o">.</span><span class="n">setCellProps</span><span class="p">([</span><span class="n">i</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="p">{</span><span class="n">backgroundColor</span><span class="p">:</span> <span class="s2">&quot;black&quot;</span><span class="p">});</span>
        <span class="p">})</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This uses <code class="docutils literal notranslate"><span class="pre">_.range()</span></code>, a function from <a class="reference external" href="https://lodash.com/">lodash</a>. Lodash is included in the skeleton library, so you can use all the
utlities it provides out of the box. The <cite>range(a, b)</cite> function creates an array of integers between <em>a</em> and <em>b-1</em>, which we can then iterate through.</p>
<p>In the original paper, the authors use 12 base mazes, where each maze contains 7 teronimo-shaped obstacles. These base mazes can also be rotated, while the start and
end points are kept fixed, to create visually different trials. Let’s start by defining a couple of methods:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>A method that takes in a maze layout and applies it to the grid</p></li>
<li><p>A method that contains base maze layout definitions</p></li>
</ol>
</div></blockquote>
<p>To begin, we’ll use a single maze layout, taken from the original paper.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">CustomGrid</span> <span class="n">extends</span> <span class="n">GridWorld</span><span class="p">{</span>
    <span class="n">constructor</span><span class="p">(){</span>
        <span class="nb">super</span><span class="p">(</span><span class="mi">50</span><span class="p">,</span> <span class="mi">40</span><span class="p">,</span> <span class="mi">40</span><span class="p">,</span> <span class="mi">70</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="s2">&quot;CENTER&quot;</span><span class="p">);</span>

        <span class="n">_</span><span class="o">.</span><span class="n">range</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span><span class="o">.</span><span class="n">forEach</span><span class="p">(</span><span class="n">i</span> <span class="o">=&gt;</span> <span class="p">{</span>
            <span class="n">this</span><span class="o">.</span><span class="n">setCellProps</span><span class="p">([</span><span class="mi">5</span><span class="p">,</span> <span class="n">i</span><span class="p">],</span> <span class="p">{</span><span class="n">backgroundColor</span><span class="p">:</span> <span class="s2">&quot;black&quot;</span><span class="p">});</span>
            <span class="n">this</span><span class="o">.</span><span class="n">setCellProps</span><span class="p">([</span><span class="n">i</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="p">{</span><span class="n">backgroundColor</span><span class="p">:</span> <span class="s2">&quot;black&quot;</span><span class="p">});</span>
        <span class="p">})</span>

        <span class="o">//</span> <span class="o">...</span> <span class="n">New</span> <span class="n">code</span> <span class="o">...</span> <span class="o">//</span>
        <span class="n">this</span><span class="o">.</span><span class="n">generateRounds</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="o">//</span> <span class="o">...</span> <span class="n">New</span> <span class="n">code</span> <span class="o">...</span> <span class="o">//</span>
    <span class="n">displayRound</span><span class="p">(</span><span class="n">layout</span><span class="p">){</span>
        <span class="o">//</span> <span class="n">Place</span> <span class="n">blue</span> <span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">e</span><span class="o">.</span> <span class="n">variable</span><span class="p">)</span> <span class="n">obstacles</span> <span class="n">on</span> <span class="n">the</span> <span class="n">grid</span>
        <span class="n">layout</span><span class="o">.</span><span class="n">forEach</span><span class="p">(</span><span class="n">i</span> <span class="o">=&gt;</span> <span class="p">{</span>
            <span class="n">this</span><span class="o">.</span><span class="n">setCellProps</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="p">{</span><span class="n">backgroundColor</span><span class="p">:</span> <span class="s2">&quot;#0606cd&quot;</span><span class="p">})</span>
        <span class="p">})</span>
    <span class="p">}</span>

    <span class="n">generateRounds</span><span class="p">(){</span>
        <span class="o">//</span> <span class="n">Each</span> <span class="n">maze</span> <span class="n">contains</span> <span class="mi">7</span> <span class="n">tetronimo</span> <span class="n">obstacles</span><span class="p">,</span> <span class="n">each</span> <span class="n">of</span> <span class="n">which</span> <span class="ow">is</span> <span class="mi">4</span> <span class="n">blocks</span> <span class="ow">in</span> <span class="n">an</span> <span class="s1">&#39;L&#39;</span> <span class="n">shape</span>
        <span class="n">this</span><span class="o">.</span><span class="n">mazes</span> <span class="o">=</span> <span class="p">{</span>
            <span class="o">//</span> <span class="n">These</span> <span class="n">are</span> <span class="n">the</span> <span class="n">coordinates</span> <span class="n">of</span> <span class="nb">all</span> <span class="n">the</span> <span class="n">obstacles</span><span class="p">,</span> <span class="ow">not</span> <span class="n">including</span> <span class="n">the</span> <span class="n">central</span> <span class="n">cross</span>
            <span class="mi">1</span><span class="p">:</span> <span class="p">[</span>
                <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]],</span>
                <span class="p">[[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">]],</span>
                <span class="p">[[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">]],</span>
                <span class="p">[[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">8</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">8</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">8</span><span class="p">,</span> <span class="mi">6</span><span class="p">]],</span>
                <span class="p">[[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">7</span><span class="p">],</span> <span class="p">[</span><span class="mi">8</span><span class="p">,</span> <span class="mi">7</span><span class="p">],</span> <span class="p">[</span><span class="mi">9</span><span class="p">,</span> <span class="mi">7</span><span class="p">],</span> <span class="p">[</span><span class="mi">9</span><span class="p">,</span> <span class="mi">8</span><span class="p">]],</span>
                <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">9</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">9</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">9</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">10</span><span class="p">]],</span>
                <span class="p">[[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">9</span><span class="p">],</span> <span class="p">[</span><span class="mi">6</span><span class="p">,</span> <span class="mi">9</span><span class="p">],</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">9</span><span class="p">],</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">10</span><span class="p">]]</span>
            <span class="p">]</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This is a solid starting point, as it allows us to render a maze to the grid. In the coming sections, we’ll define more robust ways of applying layouts.
Refreshing the page won’t show anything, as we need to manually call <code class="docutils literal notranslate"><span class="pre">displayRound</span></code>. Add the following into your <cite>setup</cite> function, or call from the console:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">content</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">displayRound</span><span class="p">(</span><span class="n">_</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="n">content</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">mazes</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
</pre></div>
</div>
<p>Here, we’re using another lodash function: <em>_.flatten</em>. Our maze layout is a length-7 array, where each row is an array of 4 coordinates. Flattening the array
works like <em>numpy.flatten</em> or <em>torch.flatten</em> in Python - we’re changing the array shape from (7, 4, 2) to (28, 2).</p>
<p>Let’s add a player token to the grid. The starting position is fixed at [10, 0], i.e. the bottom left hand cell of the grid. To do this, we’ll introduce
the idea of <em>overlays</em>, which are primitives that can be placed ontop of specified grid cells. This makes it easy to build up mazes with multiple
interactive components, that can be addressed separately to the cell objects. Overlays take in 3 parameters:</p>
<blockquote>
<div><ul class="simple">
<li><p><em>name</em>: A unique identifier for the overlay, such as “character”, “portal”, “endpointIMage”, etc.</p></li>
<li><p><em>cellId</em>: An id indicating which cell to place the overlay ‘in’. This accepts either index or coordinates. Multiple overlays can be placed in a cell at once.</p></li>
<li><p><em>overlayObj</em>: A psychex object - what you actually want to draw. Could be a pImage, pCircle, pRectangle - even another gridworld object!</p></li>
</ul>
</div></blockquote>
<p>Inside our constructor, we’ll create a reference to our character token and overlay it on the start position:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">Add</span> <span class="n">character</span> <span class="n">token</span>
<span class="n">this</span><span class="o">.</span><span class="n">character</span> <span class="o">=</span> <span class="n">new</span> <span class="n">pCircle</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">{</span><span class="n">backgroundColor</span><span class="p">:</span> <span class="s2">&quot;yellow&quot;</span><span class="p">});</span>
<span class="n">this</span><span class="o">.</span><span class="n">playerStart</span> <span class="o">=</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">0</span><span class="p">];</span>
<span class="n">this</span><span class="o">.</span><span class="n">addOverlay</span><span class="p">(</span><span class="s2">&quot;player&quot;</span><span class="p">,</span> <span class="n">this</span><span class="o">.</span><span class="n">playerStart</span><span class="p">,</span> <span class="n">this</span><span class="o">.</span><span class="n">character</span><span class="p">);</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The position parameters when overlaying an object work differently to how you’d use them normally. Instead of being coordinates on the screen,
they denote the distance from the centre of the specified cell. Overlays are designed to <em>always</em> be centred, so passing in coordinates <em>0, 0</em>
means the object is centered on the cell, and <em>1, 1</em> means it is <em>1%</em> in <em>x</em> and <em>y</em> off-centre. This can be useful especially with elements such as
text, where you might want to fine-tune alignment. This also accepts negative offsets.</p>
</div>
<p>Let’s also create a method called <em>initialiseRound</em>, where we can store and reset round-based settings, and create a variable called <em>playerPos</em> to track step-by-step position:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">initialiseRound</span><span class="p">(){</span>
    <span class="n">this</span><span class="o">.</span><span class="n">playerPos</span> <span class="o">=</span> <span class="n">this</span><span class="o">.</span><span class="n">playerStart</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>And call this is the constructor:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">constructor</span><span class="p">(){</span>

    <span class="o">//</span> <span class="o">...</span> <span class="n">preamble</span> <span class="o">...</span> <span class="o">//</span>

    <span class="n">this</span><span class="o">.</span><span class="n">initialiseRound</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="movement-control-and-key-press-events">
<h2>Movement Control and Key-Press Events<a class="headerlink" href="#movement-control-and-key-press-events" title="Link to this heading"></a></h2>
<p><em>Make it mooooove</em></p>
<p>Now we’ll go over how to attach events to key-presses, so the player can move the token. Psychex allows you to attach callbacks to any key-press. The
browser will then listen for key-presses and run the appropriate function. The <em>Gridworld</em> class provides an additional wrapper for this, called <em>handleMovement</em>.</p>
<p>When building a game like this where a player moves through a maze, you may want 2 separate callbacks:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p><em>before movement</em> - to implement rules about where they can move, i.e. not into walls or obstacles</p></li>
<li><p><em>after movement</em> - to apply logic after a move, such as updating position, changing an aesthetic, etc.</p></li>
</ol>
</div></blockquote>
<p>The <em>handleMovement</em> method allows you to pass in each of these, which it’ll wrap into a single callback. The first will run, and if it returns <em>true</em>,
it will trigger the second. You can also define a control <em>mode</em>, and specify whether the player should use arrow keys, the <em>w-a-s-d</em> keys, or just operate
through mouse clicks.</p>
<p>Of course, if you don’t want to use this, you can just write your own using the ordinary key-press register (see user interactions docs).</p>
<p>We’ll make a new wrapper function called <em>movementControl</em>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>movementControl(){

    // Define a function we can use as a callback to see if the player is allowed to move
    const preMovement = () =&gt; {
        // Use the gridworld `checkBounds` method that detects grid boundaries and computes new position based on input type
        // It takes the current player position, and the keyword &#39;key&#39;, which is the most recently pressed key,
        // and returns {allowed: true/false, pos: coords}
        let canMove = this.checkBounds(this.playerPos, key);
        if (canMove.allowed){
            // If the move is allowed, canMove.allowed == true, and canMove.pos is the new position
            // Update the player position
            this.playerPos = canMove.pos;
            // Draw the overlay at the new position, using updateOverlay()
            this.updateOverlay(&quot;player&quot;, {coords: canMove.pos});
        }
    }

    // Pass this function into handleMovement, the parent function
    this.handleMovement(&quot;arrows&quot;, preMovement);
}
</pre></div>
</div>
<p>And as always, call it in the constructor. NB: this needs to be called <strong>before</strong> <em>initialiseRound</em>, so we have access to <em>playerPos</em>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="o">...</span> <span class="n">constructor</span> <span class="n">preamble</span> <span class="o">...</span> <span class="o">//</span>
<span class="n">this</span><span class="o">.</span><span class="n">generateRounds</span><span class="p">();</span>
<span class="o">//</span> <span class="n">Calling</span> <span class="n">it</span> <span class="n">here</span><span class="p">,</span> <span class="k">for</span> <span class="n">instance</span><span class="p">,</span> <span class="n">would</span> <span class="n">be</span> <span class="n">fine</span>
<span class="n">this</span><span class="o">.</span><span class="n">movementControl</span><span class="p">();</span>
</pre></div>
</div>
<p>If you refresh the page, you should be able to move freely around the grid (including through the obstacles!).</p>
<p>Let’s now update our code to block the user from going through obstacles or through the central cross.</p>
<p>First, we’ll add a property called <em>isCross</em> to each of the central cross cells. Inside the constructor, when we set the cross background colour as black, change the code to the following:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">_</span><span class="o">.</span><span class="n">range</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span><span class="o">.</span><span class="n">forEach</span><span class="p">(</span><span class="n">i</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="n">this</span><span class="o">.</span><span class="n">setCellProps</span><span class="p">([</span><span class="mi">5</span><span class="p">,</span> <span class="n">i</span><span class="p">],</span> <span class="p">{</span><span class="n">backgroundColor</span><span class="p">:</span> <span class="s2">&quot;black&quot;</span><span class="p">});</span>
    <span class="n">this</span><span class="o">.</span><span class="n">setCellProps</span><span class="p">([</span><span class="n">i</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="p">{</span><span class="n">backgroundColor</span><span class="p">:</span> <span class="s2">&quot;black&quot;</span><span class="p">});</span>

    <span class="o">//</span> <span class="o">...</span> <span class="n">Add</span> <span class="n">new</span> <span class="n">code</span> <span class="n">below</span> <span class="o">...</span> <span class="o">//</span>
    <span class="n">this</span><span class="o">.</span><span class="n">getCell</span><span class="p">([</span><span class="mi">5</span><span class="p">,</span> <span class="n">i</span><span class="p">])</span><span class="o">.</span><span class="n">isCross</span> <span class="o">=</span> <span class="n">true</span><span class="p">;</span>
    <span class="n">this</span><span class="o">.</span><span class="n">getCell</span><span class="p">([</span><span class="n">i</span><span class="p">,</span> <span class="mi">5</span><span class="p">])</span><span class="o">.</span><span class="n">isCross</span> <span class="o">=</span> <span class="n">true</span><span class="p">;</span>
<span class="p">})</span>
</pre></div>
</div>
<p>We do this in the constructor since they’ll stay constant every round. Let’s edit the function <em>displayRound</em> that we previously wrote, so that after we
change the colour of an obstacle to blue, we also give it a tag called <em>isObstacle</em>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">displayRound</span><span class="p">(</span><span class="n">layout</span><span class="p">){</span>
    <span class="o">//</span> <span class="n">Place</span> <span class="n">blue</span> <span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">e</span><span class="o">.</span> <span class="n">variable</span><span class="p">)</span> <span class="n">obstacles</span> <span class="n">on</span> <span class="n">the</span> <span class="n">grid</span>
    <span class="n">layout</span><span class="o">.</span><span class="n">forEach</span><span class="p">(</span><span class="n">i</span> <span class="o">=&gt;</span> <span class="p">{</span>
        <span class="n">this</span><span class="o">.</span><span class="n">setCellProps</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="p">{</span><span class="n">backgroundColor</span><span class="p">:</span> <span class="s2">&quot;#0606cd&quot;</span><span class="p">})</span>

        <span class="o">//</span> <span class="o">---</span> <span class="n">New</span> <span class="n">code</span> <span class="o">---</span> <span class="o">//</span>
        <span class="n">this</span><span class="o">.</span><span class="n">getCell</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">.</span><span class="n">isObstacle</span> <span class="o">=</span> <span class="n">true</span><span class="p">;</span>
    <span class="p">})</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This uses <em>getCell</em>, a method from the parent class that returns a reference to a cell from a given index.</p>
<p>Finally, we’ll update the movement control to check if the next cell is an obstacle or a cross. We can do this but getting a reference to the
proposed next cell returned by <em>canMove</em> and passing it into <em>getCell()</em>, then checking if it has either the <em>isCross</em> or <em>isObstacle</em> attributes. Inside <em>movementControl</em>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>let canMove = this.checkBounds(this.playerPos, key);

// --- New code --- //
let isBlocked = (this.getCell(canMove.pos).isCross || this.getCell(canMove.pos).isObstacle);

// And update to check it&#39;s not a boundary or a blocked cell
if (canMove.allowed &amp;&amp; !isBlocked){
    // If the move is allowed, canMove.allowed == true, and canMove.pos is the new position
    // Update the player position
    this.playerPos = canMove.pos;
    // Draw the overlay at the new position, using updateOverlay()
    this.updateOverlay(&quot;player&quot;, {coords: canMove.pos});
}
</pre></div>
</div>
<p>Now we have movement, and the player can’t walk through walls!</p>
<p>We have a couple more changes to make to match the original study, namely:</p>
<blockquote>
<div><ul class="simple">
<li><p>Add a path to show where the player’s been</p></li>
<li><p>Add an endpoint that acts as a countdown timer</p></li>
<li><p>Start a new round when the countdown elapses, or when they reach the endpoint.</p></li>
</ul>
</div></blockquote>
<p>The first is simple. If the movement is allowed, but before position is updated, we’ll set the cell colour to be a light green. Inside <em>movementControl</em></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>if (canMove.allowed &amp;&amp; !isBlocked){
    // ... New code ... //
    // Update cell backgroundColor to be green
    this.setCellProps(this.playerPos, {backgroundColor: &#39;#5f9c56&#39;}); // a green hex code
}
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The authors originally used a dashed line as a path rather than colouring the squares. We could implement this adding an <cite>line</cite> overlay to
each cell instead of setting the cell props - but changing colour works just fine and is easier to implement.</p>
</div>
</section>
<section id="adding-more-complex-overlays">
<h2>Adding More Complex Overlays<a class="headerlink" href="#adding-more-complex-overlays" title="Link to this heading"></a></h2>
<p>Secondly, we’ll add a countdown timer overlay on the endpoint cell. Inside the constructor, define a timer object and overlay it onto the end position.
Again, we want this to be called before <em>initialiseRound</em> or <em>movementControl</em>, so we have a reference to it within those methods:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">Add</span> <span class="n">timer</span>
<span class="n">this</span><span class="o">.</span><span class="n">timer</span> <span class="o">=</span> <span class="n">new</span> <span class="n">Countdown</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">setGraphic</span><span class="p">(</span><span class="s2">&quot;arc&quot;</span><span class="p">,</span> <span class="p">{</span><span class="n">w</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="n">h</span><span class="p">:</span><span class="mi">4</span><span class="p">,</span> <span class="n">borderColor</span><span class="p">:</span> <span class="s2">&quot;green&quot;</span><span class="p">,</span> <span class="n">borderWidth</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span> <span class="n">backgroundColor</span><span class="p">:</span> <span class="s2">&quot;rgba(0, 0, 0, 0)&quot;</span><span class="p">});</span>
<span class="n">this</span><span class="o">.</span><span class="n">addOverlay</span><span class="p">(</span><span class="s2">&quot;timer&quot;</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">],</span> <span class="n">this</span><span class="o">.</span><span class="n">timer</span><span class="p">);</span>
</pre></div>
</div>
<p>The timer is set to ellapse 5 seconds after being started, and we’ve attached a decreasing arc as a graphic. Bear in mind that it won’t start counting
down until we run <em>this.timer.reset()</em>. Now, let’s populate <em>initialiseRound</em> with everything we need to start a new round. Our flow is:</p>
<blockquote>
<div><ul class="simple">
<li><p>Reset player position to <em>playerStart</em></p></li>
<li><p>Clear the path of the previous round</p></li>
<li><p>Clear everything marked as an obstacle (otherwise we’ll have invisible walls!)</p></li>
<li><p>Display a new maze layout</p></li>
<li><p>Reset the timer</p></li>
</ul>
</div></blockquote>
<p>To reset player position, call the <em>updateOverlay</em> method:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">initialiseRound</span><span class="p">(){</span>
    <span class="n">this</span><span class="o">.</span><span class="n">playerPos</span> <span class="o">=</span> <span class="n">this</span><span class="o">.</span><span class="n">playerStart</span><span class="p">;</span>
    <span class="n">this</span><span class="o">.</span><span class="n">updateOverlay</span><span class="p">(</span><span class="s2">&quot;player&quot;</span><span class="p">,</span> <span class="p">{</span><span class="n">coords</span><span class="p">:</span> <span class="n">this</span><span class="o">.</span><span class="n">playerPos</span><span class="p">});</span>
<span class="p">}</span>
</pre></div>
</div>
<p>To clear the path, we need to track where we’ve been. This is useful data to have anyway, so let’s add a variable called <em>path</em> into the constructor (again, before we call <em>initialiseRound</em>
or <em>movementControl</em>):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">We</span> <span class="n">can</span> <span class="n">start</span> <span class="n">it</span> <span class="n">off</span> <span class="k">with</span> <span class="n">the</span> <span class="n">start</span> <span class="n">position</span>
<span class="n">this</span><span class="o">.</span><span class="n">path</span> <span class="o">=</span> <span class="p">[</span><span class="n">this</span><span class="o">.</span><span class="n">playerStart</span><span class="p">];</span>
</pre></div>
</div>
<p>And after we’ve moved to a new position in <em>movementControl</em>, after we update the overlay:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">this</span><span class="o">.</span><span class="n">updateOverlay</span><span class="p">(</span><span class="s2">&quot;player&quot;</span><span class="p">,</span> <span class="p">{</span><span class="n">coords</span><span class="p">:</span> <span class="n">canMove</span><span class="o">.</span><span class="n">pos</span><span class="p">});</span>

<span class="o">//</span> <span class="o">---</span> <span class="n">New</span> <span class="n">code</span> <span class="o">---</span> <span class="o">//</span>
<span class="o">//</span> <span class="n">Update</span> <span class="n">the</span> <span class="n">path</span>
<span class="n">this</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="n">this</span><span class="o">.</span><span class="n">playerPos</span><span class="p">);</span>
</pre></div>
</div>
<p>Now we have a path, back in <em>initialiseRound</em> we can clear it:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">Clear</span> <span class="n">previous</span> <span class="n">path</span>
<span class="n">this</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">forEach</span><span class="p">(</span><span class="nb">id</span> <span class="o">=&gt;</span> <span class="p">{</span><span class="n">this</span><span class="o">.</span><span class="n">setCellProps</span><span class="p">(</span><span class="nb">id</span><span class="p">,</span> <span class="p">{</span><span class="n">backgroundColor</span><span class="p">:</span> <span class="s1">&#39;white&#39;</span><span class="p">})});</span>
<span class="o">//</span> <span class="n">Reset</span> <span class="n">path</span> <span class="n">variable</span>
<span class="n">this</span><span class="o">.</span><span class="n">path</span> <span class="o">=</span> <span class="p">[</span><span class="n">this</span><span class="o">.</span><span class="n">playerPos</span><span class="p">];</span>
</pre></div>
</div>
<p>To remove all obstacles, we need to do the opposite to the <cite>displayRound</cite> function. Let’s create another function called <cite>clearRound</cite>. This
will take in the current maze ID as input:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">clearRound</span><span class="p">(</span><span class="n">mazeId</span><span class="p">){</span>
    <span class="o">//</span> <span class="n">Skip</span> <span class="k">if</span> <span class="n">this</span> <span class="ow">is</span> <span class="n">the</span> <span class="n">first</span> <span class="nb">round</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">mazeId</span> <span class="o">==</span> <span class="n">undefined</span><span class="p">){</span><span class="k">return</span><span class="p">}</span>
    <span class="n">let</span> <span class="n">layout</span> <span class="o">=</span> <span class="n">_</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="n">this</span><span class="o">.</span><span class="n">mazes</span><span class="p">[</span><span class="n">this</span><span class="o">.</span><span class="n">mazeId</span><span class="p">])</span>
    <span class="n">layout</span><span class="o">.</span><span class="n">forEach</span><span class="p">(</span><span class="n">i</span> <span class="o">=&gt;</span> <span class="p">{</span>
        <span class="n">this</span><span class="o">.</span><span class="n">setCellProps</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="p">{</span><span class="n">backgroundColor</span><span class="p">:</span> <span class="s2">&quot;white&quot;</span><span class="p">});</span>
        <span class="n">this</span><span class="o">.</span><span class="n">getCell</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">.</span><span class="n">isObstacle</span> <span class="o">=</span> <span class="n">false</span><span class="p">;</span>
    <span class="p">})</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Let’s randomly generate a new maze layout each time. Currently, we’ve only defined one, but we’ll have more soon! If you’re calling <em>displayRound</em> in the constructor,
you can delete that line and we’ll replace it here:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">Randomly</span> <span class="n">select</span> <span class="n">a</span> <span class="n">maze</span><span class="p">:</span>
<span class="n">this</span><span class="o">.</span><span class="n">mazeId</span> <span class="o">=</span> <span class="n">_</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">Object</span><span class="o">.</span><span class="n">keys</span><span class="p">(</span><span class="n">this</span><span class="o">.</span><span class="n">mazes</span><span class="p">))</span>
<span class="o">//</span> <span class="n">Display</span> <span class="n">the</span> <span class="nb">round</span>
<span class="n">this</span><span class="o">.</span><span class="n">displayRound</span><span class="p">(</span><span class="n">_</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="n">this</span><span class="o">.</span><span class="n">mazes</span><span class="p">[</span><span class="n">this</span><span class="o">.</span><span class="n">mazeId</span><span class="p">]));</span>
</pre></div>
</div>
<p>In the first line, we take all the maze IDs, where <code class="docutils literal notranslate"><span class="pre">this.mazes</span> <span class="pre">=</span> <span class="pre">{1:</span> <span class="pre">[...],</span> <span class="pre">2:</span> <span class="pre">[...],</span> <span class="pre">3:</span> <span class="pre">[...]}</span></code>, and <code class="docutils literal notranslate"><span class="pre">Object.keys(this.mazes)</span> <span class="pre">=</span> <span class="pre">[1,</span> <span class="pre">2,</span> <span class="pre">3]</span></code>.
Then, we flatten and display our chosen maze. Remember, this also assigns those cells with <em>isObstacle</em> using our previous code.</p>
<p>Now, we can set the timer. In the original study, the player has 5 seconds to move on their <strong>first</strong> step, before the time elapses. After this,
they only have 1 second to move per step. We can edit the amount of time they have via the <em>endtime</em> attribute of the timer. Add the following:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">Reset</span> <span class="n">timer</span> <span class="n">to</span> <span class="mi">5</span> <span class="n">seconds</span> <span class="k">for</span> <span class="n">first</span> <span class="n">movement</span><span class="p">,</span> <span class="ow">and</span> <span class="n">then</span> <span class="n">start</span> <span class="n">it</span>
<span class="n">this</span><span class="o">.</span><span class="n">timer</span><span class="o">.</span><span class="n">endtime</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
<span class="n">this</span><span class="o">.</span><span class="n">timer</span><span class="o">.</span><span class="n">reset</span><span class="p">();</span>
</pre></div>
</div>
<p>We want the timer to reset every time the player makes a move. Remember earlier when we were building <em>movementControl</em>, and we could pass a
pre-move and post-move callback into the parent <em>handleMovement</em>? Now we’re going to use the post-movement callback to handle the timer. Underneath our
<em>preMovement</em> function, add a <em>postMovement</em> function:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">const</span> <span class="n">postMovement</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>

<span class="p">}</span>
</pre></div>
</div>
<p>In here, we’re going to check if this is the end state or not, and act accordingly. First of all, let’s create a vbariable to store out end state. In the constructor, add:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">this</span><span class="o">.</span><span class="n">playerEnd</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">];</span>
</pre></div>
</div>
<p>And back in our <em>postMovement</em> callback:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">const</span> <span class="n">postMovement</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">_</span><span class="o">.</span><span class="n">isEqual</span><span class="p">(</span><span class="n">this</span><span class="o">.</span><span class="n">playerPos</span><span class="p">,</span> <span class="n">this</span><span class="o">.</span><span class="n">playerEnd</span><span class="p">)){</span>
        <span class="o">//</span> <span class="o">...</span> <span class="o">//</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="o">//</span> <span class="o">...</span> <span class="o">//</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>What’s the point of the <code class="docutils literal notranslate"><span class="pre">_.isEqual()</span></code>? Why not do <code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">(this.playerPos</span> <span class="pre">==</span> <span class="pre">this.playerEnd){}</span></code>?</p>
<p>Try it out for yourself, open up a console, and type:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">==</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">];</span>
</pre></div>
</div>
<p>You’ll see that it returns <code class="docutils literal notranslate"><span class="pre">false</span></code>! That’s because JavaScript is looking to see if these are the <em>exact same object</em>, not just if
they are the same type of object, containing the same elements. What we want to do is a <em>shallow comparison</em>, where we just look to see
if they contain the same values. So, we use the Lodash <code class="docutils literal notranslate"><span class="pre">isEqual()</span></code> function.</p>
</div>
<p>Let’s populate our <em>postMovement</em> callback with the logic for both outcomes:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">const</span> <span class="n">postMovement</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">_</span><span class="o">.</span><span class="n">isEqual</span><span class="p">(</span><span class="n">this</span><span class="o">.</span><span class="n">playerPos</span><span class="p">,</span> <span class="n">this</span><span class="o">.</span><span class="n">playerEnd</span><span class="p">)){</span>
            <span class="o">//</span> <span class="n">If</span> <span class="n">this</span> <span class="ow">is</span> <span class="n">the</span> <span class="n">end</span> <span class="n">position</span>
            <span class="n">this</span><span class="o">.</span><span class="n">timer</span><span class="o">.</span><span class="n">pause</span><span class="p">();</span>
            <span class="n">this</span><span class="o">.</span><span class="n">initialiseRound</span><span class="p">();</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">this</span><span class="o">.</span><span class="n">timer</span><span class="o">.</span><span class="n">endtime</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
            <span class="n">this</span><span class="o">.</span><span class="n">timer</span><span class="o">.</span><span class="n">reset</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">}</span>
</pre></div>
</div>
<p>Now, if we land at the end state, the timer will pause, and we’ll begin a new round. If this isn’t the end state, we’ll set the timer to only last for 1 second,
and then we’ll reset it. Don’t forget to add this callback to <em>handleMovement</em>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">this</span><span class="o">.</span><span class="n">handleMovement</span><span class="p">(</span><span class="s2">&quot;arrows&quot;</span><span class="p">,</span> <span class="n">preMovement</span><span class="p">,</span> <span class="n">postMovement</span><span class="p">);</span>
</pre></div>
</div>
<p>And, importantly, we have to <code class="docutils literal notranslate"><span class="pre">return</span> <span class="pre">true</span></code> from the preMovement callback - remember, the <em>postMovement</em> will only run if <em>preMovement</em> tells it it
can do by returning true!</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="o">...</span> <span class="n">previous</span> <span class="n">code</span> <span class="o">...</span> <span class="o">//</span>
<span class="o">//</span> <span class="n">Update</span> <span class="n">the</span> <span class="n">path</span>
<span class="n">this</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="n">this</span><span class="o">.</span><span class="n">playerPos</span><span class="p">);</span>

<span class="o">//</span> <span class="o">...</span> <span class="n">new</span> <span class="n">code</span> <span class="o">...</span> <span class="o">//</span>
<span class="k">return</span> <span class="n">true</span><span class="p">;</span>
</pre></div>
</div>
<p>Now you should be able to go from start to end, and see it reset. The final thing to do is set the rule for when the timer elapses.
To do this, we’ll define <em>timer.onTimeUp</em>. Check out the <cite>Countdown</cite> docs for more info, but essentially this just
gives the timer a function to call once it runs out. Inside the constructor, where we define the timer, add the following:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">this</span><span class="o">.</span><span class="n">timer</span><span class="o">.</span><span class="n">onTimeUp</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
        <span class="n">this</span><span class="o">.</span><span class="n">initialiseRound</span><span class="p">();</span>
    <span class="p">}</span>
</pre></div>
</div>
<p>Now, refresh your page to see the changes!</p>
<p>Perhaps we don’t want to endure the Sisyphean nightmare of endless mazes and timers. Let’s add a manual pause that we can turn off for the actual
experiment, but makes debugging more pleasant. In the constructor:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">psychex</span><span class="o">.</span><span class="n">keyPressEvents</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="s2">&quot;Enter&quot;</span><span class="p">,</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="n">console</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="s2">&quot;Enter&quot;</span><span class="p">)</span>
    <span class="n">this</span><span class="o">.</span><span class="n">timer</span><span class="o">.</span><span class="n">pause</span><span class="p">();</span>
<span class="p">})</span>
</pre></div>
</div>
<p>Now, hitting “Enter” will pause the timer, and moving as normal will resume it.</p>
<p>So we can experience playing the game more realistically, here are a set of 3 mazes the authors give in the original paper. Feel free to copy them into
the <em>generateRounds</em> function:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">this</span><span class="o">.</span><span class="n">mazes</span> <span class="o">=</span> <span class="p">{</span>
        <span class="o">//</span> <span class="n">These</span> <span class="n">are</span> <span class="n">the</span> <span class="n">coordinates</span> <span class="n">of</span> <span class="nb">all</span> <span class="n">the</span> <span class="n">obstacles</span><span class="p">,</span> <span class="ow">not</span> <span class="n">including</span> <span class="n">the</span> <span class="n">central</span> <span class="n">cross</span>
        <span class="mi">1</span><span class="p">:</span> <span class="p">[</span>
            <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]],</span>
            <span class="p">[[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">]],</span>
            <span class="p">[[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">]],</span>
            <span class="p">[[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">8</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">8</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">8</span><span class="p">,</span> <span class="mi">6</span><span class="p">]],</span>
            <span class="p">[[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">7</span><span class="p">],</span> <span class="p">[</span><span class="mi">8</span><span class="p">,</span> <span class="mi">7</span><span class="p">],</span> <span class="p">[</span><span class="mi">9</span><span class="p">,</span> <span class="mi">7</span><span class="p">],</span> <span class="p">[</span><span class="mi">9</span><span class="p">,</span> <span class="mi">8</span><span class="p">]],</span>
            <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">9</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">9</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">9</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">10</span><span class="p">]],</span>
            <span class="p">[[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">9</span><span class="p">],</span> <span class="p">[</span><span class="mi">6</span><span class="p">,</span> <span class="mi">9</span><span class="p">],</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">9</span><span class="p">],</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">10</span><span class="p">]]</span>
        <span class="p">],</span>
        <span class="mi">2</span><span class="p">:</span> <span class="p">[</span>
            <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">]],</span>
            <span class="p">[[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]],</span>
            <span class="p">[[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">6</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">2</span><span class="p">]],</span>
            <span class="p">[[</span><span class="mi">8</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">9</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">6</span><span class="p">]],</span>
            <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">10</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">10</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">9</span><span class="p">]],</span>
            <span class="p">[[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">10</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">],</span> <span class="p">[</span><span class="mi">6</span><span class="p">,</span> <span class="mi">10</span><span class="p">],</span> <span class="p">[</span><span class="mi">6</span><span class="p">,</span> <span class="mi">9</span><span class="p">]],</span>
            <span class="p">[[</span><span class="mi">8</span><span class="p">,</span> <span class="mi">10</span><span class="p">],</span> <span class="p">[</span><span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">],</span> <span class="p">[</span><span class="mi">9</span><span class="p">,</span> <span class="mi">9</span><span class="p">],</span> <span class="p">[</span><span class="mi">9</span><span class="p">,</span> <span class="mi">8</span><span class="p">]],</span>
        <span class="p">],</span>
        <span class="mi">3</span><span class="p">:</span> <span class="p">[</span>
            <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">]],</span>
            <span class="p">[[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">]],</span>
            <span class="p">[[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">6</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">1</span><span class="p">]],</span>
            <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">]],</span>
            <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">9</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">8</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">8</span><span class="p">]],</span>
            <span class="p">[[</span><span class="mi">6</span><span class="p">,</span> <span class="mi">10</span><span class="p">],</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">10</span><span class="p">],</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">9</span><span class="p">],</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">]],</span>
            <span class="p">[[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">7</span><span class="p">],</span> <span class="p">[</span><span class="mi">8</span><span class="p">,</span> <span class="mi">7</span><span class="p">],</span> <span class="p">[</span><span class="mi">9</span><span class="p">,</span> <span class="mi">7</span><span class="p">],</span> <span class="p">[</span><span class="mi">9</span><span class="p">,</span> <span class="mi">6</span><span class="p">]],</span>
        <span class="p">]</span>
    <span class="p">}</span>
</pre></div>
</div>
<p>There are various ways you generate mazes in a more procedural way, for instance:</p>
<blockquote>
<div><ul class="simple">
<li><p>Write a function that randomly places the tetronimos, test out playing the round, and write a keypress event that logs the maze layout if it’s playable</p></li>
<li><p>Design rounds by hand to gain the finest-grain control over the stimuli, and then paste them in here, or as an object in another file that you load in</p></li>
<li><p>Write an offline script that creates maze layouts (this doesn’t even have to be in JavaScript, you could use Python, Java, or anything else you like). Then place these server-side and load them using the Psychex <code class="docutils literal notranslate"><span class="pre">Game.loadDataFromServer()</span></code> function into your gridworld class.</p></li>
</ul>
</div></blockquote>
<p>Psychex supports all of these options, and offers the extensibility to create alternatives.</p>
</section>
<section id="overriding-the-parent-draw-method">
<h2>Overriding the Parent Draw Method<a class="headerlink" href="#overriding-the-parent-draw-method" title="Link to this heading"></a></h2>
<p>Finally, let’s enhance the user experience by adding some feedback text throughout the round. Inside the constructor, define an empty string:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">this</span><span class="o">.</span><span class="n">displayText</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">;</span>
</pre></div>
</div>
<p>We want to show a message to the user after they complete a round, and after they’re timed out. Inside the function we use for <code class="docutils literal notranslate"><span class="pre">timer.onTimeUp</span></code>,
we’ll update this text, and we’ll add a <em>timeout</em>. This instructs the code to run a function after a prescribed amount of time.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">this</span><span class="o">.</span><span class="n">timer</span><span class="o">.</span><span class="n">onTimeUp</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="n">this</span><span class="o">.</span><span class="n">timer</span><span class="o">.</span><span class="n">pause</span><span class="p">();</span>
    <span class="n">this</span><span class="o">.</span><span class="n">displayText</span> <span class="o">=</span> <span class="s2">&quot;Time&#39;s up! Moving to the next round...&quot;</span><span class="p">;</span>
    <span class="n">setTimeout</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
        <span class="n">this</span><span class="o">.</span><span class="n">initialiseRound</span><span class="p">();</span>
    <span class="p">},</span> <span class="mi">2000</span><span class="p">);</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Now, when the timer ellapses, the game will wait 2s (2000ms in the code, as <em>setTimeout</em> takes milliseconds) before beginning the next round. This will
give the player chance to read the displayed text message. Importantly, note that we also add <code class="docutils literal notranslate"><span class="pre">this.timer.pause()</span></code>. This is an important concept to remember
when building games that use an <em>animation loop</em> - i.e. where a draw function runs ~60 times a second. The callback <em>onTimeUp</em> will be run every time there’s a draw loop,
so once the time has elapsed, if we created a <em>timeout</em> that waited 2 seconds before calling <em>reset</em>, it would mean that <em>onTimeUp</em> would run ~60x2=120 times until it was
next reset. So we pause the timer, to stop it calling that function. This is a common source of bugs when building games like this!</p>
<p>Next, update the <em>postMovement</em> function inside <em>movementControl</em> - where we listen for if the player is at the endpoint - doing the same as we’ve just done:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="p">(</span><span class="n">_</span><span class="o">.</span><span class="n">isEqual</span><span class="p">(</span><span class="n">this</span><span class="o">.</span><span class="n">playerPos</span><span class="p">,</span> <span class="n">this</span><span class="o">.</span><span class="n">playerEnd</span><span class="p">)){</span>
    <span class="o">//</span> <span class="n">If</span> <span class="n">this</span> <span class="ow">is</span> <span class="n">the</span> <span class="n">endpoint</span>
    <span class="n">this</span><span class="o">.</span><span class="n">timer</span><span class="o">.</span><span class="n">pause</span><span class="p">();</span>

    <span class="o">//</span> <span class="o">---</span> <span class="n">New</span> <span class="n">code</span> <span class="o">---</span> <span class="o">//</span>
    <span class="n">this</span><span class="o">.</span><span class="n">displayText</span> <span class="o">=</span> <span class="s2">&quot;Round Complete! Beginning next round...&quot;</span><span class="p">;</span>
    <span class="n">setTimeout</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
        <span class="n">this</span><span class="o">.</span><span class="n">initialiseRound</span><span class="p">();</span>
    <span class="p">},</span> <span class="mi">2000</span><span class="p">)</span>

<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="n">this</span><span class="o">.</span><span class="n">timer</span><span class="o">.</span><span class="n">endtime</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">this</span><span class="o">.</span><span class="n">timer</span><span class="o">.</span><span class="n">reset</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>And add some instructional text to <em>initialiseRound</em>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">this</span><span class="o">.</span><span class="n">displayText</span> <span class="o">=</span> <span class="s2">&quot;Use your arrow keys to move the player token&quot;</span><span class="p">;</span>
</pre></div>
</div>
<p>Finally, we have to actually draw the text. Recall that so far, we’ve just called <code class="docutils literal notranslate"><span class="pre">content.grid.draw()</span></code> inside the global <em>draw</em> function. By doing this,
we’re referencing the draw method from the parent class (psychex.Gridworld). That draw function contains all the instructions necessary to draw the grid structure
and the overlays, but if we want to add any additional custom objects, we need to extend it. Fortunately, this is very easy. Within our CusatomGridworld class, add the following method:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">draw</span><span class="p">(){</span>
    <span class="nb">super</span><span class="o">.</span><span class="n">draw</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This creates a new <em>draw</em> method, and then uses <code class="docutils literal notranslate"><span class="pre">super</span></code> to call the draw from the parent class. Effectively, this is just like saying <em>“run the parent draw function first, and
then do everything else I want in my custom class”</em>. This is exactly what we’re going to do. Let’s draw our displayText:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">draw</span><span class="p">(){</span>
    <span class="o">//</span> <span class="n">Parent</span> <span class="n">draws</span> <span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">overlays</span><span class="p">)</span>
    <span class="nb">super</span><span class="o">.</span><span class="n">draw</span><span class="p">();</span>

    <span class="o">//</span> <span class="n">Our</span> <span class="n">display</span> <span class="n">text</span>
    <span class="n">pText</span><span class="o">.</span><span class="n">draw_</span><span class="p">(</span><span class="n">this</span><span class="o">.</span><span class="n">displayText</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">80</span><span class="p">,</span> <span class="p">{</span><span class="n">fontSize</span><span class="p">:</span> <span class="mi">32</span><span class="p">});</span>
<span class="p">}</span>
</pre></div>
</div>
<p>As a final learning exercise, here we’re using a different version of <em>draw</em>. You may notice that this has an underscore attached to the end of the function name -
in Psychex, this means that this is a <em>static method</em>. A static method is just a way of drawing a primitive without having to actually create it first - note that this
will render our text, but we haven’t written <code class="docutils literal notranslate"><span class="pre">this.someText</span> <span class="pre">=</span> <span class="pre">new</span> <span class="pre">pText(this.displayText,</span> <span class="pre">50,</span> <span class="pre">50,</span> <span class="pre">{})</span></code> anywhere. Static methods can be handy as a quick way of rendering things,
especially when you won’t need to access them later or they’re unlikely to change. In this case, if we change our <em>displayText</em> variable, the static pText will update with it.</p>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="../tutorial/n_arm_bandit.html" class="btn btn-neutral float-left" title="Tutorial: N-Arm Bandit Task" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="faq.html" class="btn btn-neutral float-right" title="FAQ" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2024, Grogan, A..</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>